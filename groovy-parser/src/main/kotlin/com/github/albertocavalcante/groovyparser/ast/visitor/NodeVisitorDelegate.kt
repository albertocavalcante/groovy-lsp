package com.github.albertocavalcante.groovyparser.ast.visitor

import com.github.albertocavalcante.groovyparser.ast.NodeRelationshipTracker
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.AnnotatedNode
import org.codehaus.groovy.ast.ClassCodeVisitorSupport
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.FieldNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.ast.ModuleNode
import org.codehaus.groovy.ast.PropertyNode
import org.codehaus.groovy.ast.expr.BinaryExpression
import org.codehaus.groovy.ast.expr.ClassExpression
import org.codehaus.groovy.ast.expr.ClosureExpression
import org.codehaus.groovy.ast.expr.ConstructorCallExpression
import org.codehaus.groovy.ast.expr.DeclarationExpression
import org.codehaus.groovy.ast.expr.MethodCallExpression
import org.codehaus.groovy.ast.expr.PropertyExpression
import org.codehaus.groovy.ast.expr.VariableExpression
import org.codehaus.groovy.ast.stmt.BlockStatement
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.control.SourceUnit
import java.net.URI

/**
 * Delegate class that handles all actual node visiting for AstVisitor.
 * This separation reduces the AstVisitor function count from 37 to 10.
 *
 * TODO: This class has 29 functions, which naturally occurs in visitor pattern implementations.
 * We've excluded visitor pattern classes from detekt TooManyFunctions rule because each AST
 * node type requires its own visit method. This is a legitimate architectural pattern.
 *
 * The visitor pattern could be further optimized with:
 * - Method dispatch tables instead of individual methods
 * - Reflection-based visiting
 * - Split into specialized visitors (expressions, statements, declarations)
 */
internal class NodeVisitorDelegate(private val tracker: NodeRelationshipTracker) : ClassCodeVisitorSupport() {

    private var _sourceUnit: SourceUnit? = null
    private var currentUri: URI? = null

    public override fun getSourceUnit(): SourceUnit? = _sourceUnit

    fun visitModule(module: ModuleNode, sourceUnit: SourceUnit, uri: URI) {
        this._sourceUnit = sourceUnit
        this.currentUri = uri
        tracker.clear()
        processModule(module)
    }

    private fun processModule(module: ModuleNode) {
        pushNode(module)

        // Visit all imports in the module
        module.imports?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit star imports
        module.starImports?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit static imports
        module.staticImports?.values?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit static star imports
        module.staticStarImports?.values?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit all classes in the module
        module.classes.forEach { classNode ->
            visitClass(classNode)
        }

        // Also visit any script body code if this is a script
        if (module.statementBlock != null) {
            visitBlockStatement(module.statementBlock)
        }

        popNode()
    }

    /**
     * Push a node onto the stack and track relationships
     */
    private fun pushNode(node: ASTNode) {
        // Only track nodes with valid source positions.
        // This filters out:
        // - Synthetic nodes generated by Groovy compiler (ModuleNode, script methods, etc.)
        // - Nodes with incomplete position information
        //
        // Note: Some VariableExpressions are marked synthetic but have valid coordinates
        // (e.g., implicit access like 'println name') and should be hoverable.
        // By checking position validity instead of synthetic flag, we correctly include these.
        val hasValidPosition = node.lineNumber > 0 && node.columnNumber > 0

        if (hasValidPosition) {
            tracker.pushNode(node, currentUri)
        }
    }

    /**
     * Pop the current node from the stack
     */
    private fun popNode() {
        tracker.popNode()
    }

    /**
     * Visit annotations on an annotated node
     */
    override fun visitAnnotations(node: AnnotatedNode) {
        node.annotations?.forEach { annotation ->
            pushNode(annotation)
            try {
                processAnnotationMembers(annotation)
            } finally {
                popNode()
            }
        }
    }

    /**
     * Process annotation members to visit their expressions.
     */
    private fun processAnnotationMembers(annotation: org.codehaus.groovy.ast.AnnotationNode) {
        annotation.members?.forEach { (_, value) ->
            if (value is org.codehaus.groovy.ast.expr.Expression) {
                value.visit(this)
            }
        }
    }

    // Override visitor methods to track nodes

    override fun visitClass(node: ClassNode) {
        pushNode(node)
        try {
            super.visitClass(node)
        } finally {
            popNode()
        }
    }

    override fun visitMethod(node: MethodNode) {
        pushNode(node)
        try {
            // Visit parameters
            node.parameters?.forEach { param ->
                pushNode(param)
                popNode()
            }
            super.visitMethod(node)
        } finally {
            popNode()
        }
    }

    override fun visitField(node: FieldNode) {
        pushNode(node)
        try {
            super.visitField(node)
        } finally {
            popNode()
        }
    }

    override fun visitProperty(node: PropertyNode) {
        pushNode(node)
        try {
            super.visitProperty(node)
        } finally {
            popNode()
        }
    }

    // Expression visitors

    override fun visitMethodCallExpression(call: MethodCallExpression) {
        pushNode(call)
        try {
            // Manually visit arguments to ensure they are tracked, as standard visitor support seems flaky for ArgumentList
            val args = call.arguments
            if (args is org.codehaus.groovy.ast.expr.TupleExpression) {
                args.expressions?.forEach { it.visit(this) }
            } else {
                args?.visit(this)
            }

            // Manually visit the method expression (object and method name) instead of calling super
            // to avoid potential duplicate visitation of arguments if super were to visit them.
            call.objectExpression?.visit(this)
            call.method?.visit(this)
        } finally {
            popNode()
        }
    }

    override fun visitVariableExpression(expression: VariableExpression) {
        pushNode(expression)
        try {
            super.visitVariableExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitDeclarationExpression(expression: DeclarationExpression) {
        pushNode(expression)
        try {
            super.visitDeclarationExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitBinaryExpression(expression: BinaryExpression) {
        pushNode(expression)
        try {
            super.visitBinaryExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitPropertyExpression(expression: PropertyExpression) {
        pushNode(expression)
        try {
            super.visitPropertyExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitConstructorCallExpression(call: ConstructorCallExpression) {
        pushNode(call)
        try {
            super.visitConstructorCallExpression(call)
        } finally {
            popNode()
        }
    }

    override fun visitTupleExpression(expression: org.codehaus.groovy.ast.expr.TupleExpression) {
        pushNode(expression)
        try {
            super.visitTupleExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitClassExpression(expression: ClassExpression) {
        pushNode(expression)
        try {
            super.visitClassExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitClosureExpression(expression: ClosureExpression) {
        pushNode(expression)
        try {
            // Visit closure parameters
            expression.parameters?.forEach { param ->
                pushNode(param)
                popNode()
            }
            super.visitClosureExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitGStringExpression(expression: org.codehaus.groovy.ast.expr.GStringExpression) {
        pushNode(expression)
        try {
            super.visitGStringExpression(expression)
        } finally {
            popNode()
        }
    }

    override fun visitConstantExpression(expression: org.codehaus.groovy.ast.expr.ConstantExpression) {
        pushNode(expression)
        try {
            super.visitConstantExpression(expression)
        } finally {
            popNode()
        }
    }

    // Statement visitors

    override fun visitBlockStatement(block: BlockStatement) {
        pushNode(block)
        try {
            super.visitBlockStatement(block)
        } finally {
            popNode()
        }
    }

    override fun visitExpressionStatement(statement: ExpressionStatement) {
        pushNode(statement)
        try {
            super.visitExpressionStatement(statement)
        } finally {
            popNode()
        }
    }

    // Additional statement visitors for complete coverage

    override fun visitForLoop(loop: org.codehaus.groovy.ast.stmt.ForStatement) {
        pushNode(loop)
        try {
            super.visitForLoop(loop)
        } finally {
            popNode()
        }
    }

    override fun visitWhileLoop(loop: org.codehaus.groovy.ast.stmt.WhileStatement) {
        pushNode(loop)
        try {
            super.visitWhileLoop(loop)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitDoWhileLoop to ensure DoWhileStatement nodes are tracked.
     */
    override fun visitDoWhileLoop(loop: org.codehaus.groovy.ast.stmt.DoWhileStatement) {
        pushNode(loop)
        try {
            super.visitDoWhileLoop(loop)
        } finally {
            popNode()
        }
    }

    override fun visitIfElse(ifElse: org.codehaus.groovy.ast.stmt.IfStatement) {
        pushNode(ifElse)
        try {
            super.visitIfElse(ifElse)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitTryCatchFinally to ensure TryCatchStatement and CatchStatement nodes are tracked.
     *
     * Note: CatchStatement doesn't have its own visitor method in ClassCodeVisitorSupport,
     * so we manually track each catch statement along with its parameter and code block.
     */
    override fun visitTryCatchFinally(statement: org.codehaus.groovy.ast.stmt.TryCatchStatement) {
        pushNode(statement)
        try {
            // Manually visit catch statements to ensure they are tracked
            statement.catchStatements?.forEach { catchStmt ->
                pushNode(catchStmt)
                try {
                    // Visit the catch parameter
                    val param = catchStmt.variable
                    if (param != null) {
                        pushNode(param)
                        popNode()
                    }
                    // Visit the catch block
                    catchStmt.code?.visit(this)
                } finally {
                    popNode()
                }
            }

            // Visit try block
            statement.tryStatement?.visit(this)

            // Visit finally block
            statement.finallyStatement?.visit(this)
        } finally {
            popNode()
        }
    }

    override fun visitReturnStatement(statement: org.codehaus.groovy.ast.stmt.ReturnStatement) {
        pushNode(statement)
        try {
            super.visitReturnStatement(statement)
        } finally {
            popNode()
        }
    }

    override fun visitThrowStatement(statement: org.codehaus.groovy.ast.stmt.ThrowStatement) {
        pushNode(statement)
        try {
            super.visitThrowStatement(statement)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitSwitch to ensure SwitchStatement and all CaseStatement nodes are tracked.
     *
     * We manually visit each case statement to ensure comprehensive tracking of all switch cases,
     * including the default case. This ensures that case statements are hoverable and discoverable.
     */
    override fun visitSwitch(statement: org.codehaus.groovy.ast.stmt.SwitchStatement) {
        pushNode(statement)
        try {
            // Visit the expression being switched on
            statement.expression?.visit(this)

            // Manually visit case statements to ensure they are all tracked
            statement.caseStatements?.forEach { caseStmt ->
                visitCaseStatement(caseStmt)
            }

            // Visit the default statement if it exists
            statement.defaultStatement?.visit(this)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitCaseStatement to ensure CaseStatement nodes are tracked.
     */
    override fun visitCaseStatement(statement: org.codehaus.groovy.ast.stmt.CaseStatement) {
        pushNode(statement)
        try {
            super.visitCaseStatement(statement)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitBreakStatement to ensure BreakStatement nodes are tracked.
     */
    override fun visitBreakStatement(statement: org.codehaus.groovy.ast.stmt.BreakStatement) {
        pushNode(statement)
        try {
            super.visitBreakStatement(statement)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitContinueStatement to ensure ContinueStatement nodes are tracked.
     */
    override fun visitContinueStatement(statement: org.codehaus.groovy.ast.stmt.ContinueStatement) {
        pushNode(statement)
        try {
            super.visitContinueStatement(statement)
        } finally {
            popNode()
        }
    }
}
