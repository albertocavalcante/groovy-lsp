package com.github.albertocavalcante.groovyparser.ast.visitor

import com.github.albertocavalcante.groovyparser.ast.NodeRelationshipTracker
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.AnnotatedNode
import org.codehaus.groovy.ast.ClassCodeVisitorSupport
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.FieldNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.ast.ModuleNode
import org.codehaus.groovy.ast.PropertyNode
import org.codehaus.groovy.ast.expr.BinaryExpression
import org.codehaus.groovy.ast.expr.ClassExpression
import org.codehaus.groovy.ast.expr.ClosureExpression
import org.codehaus.groovy.ast.expr.ConstructorCallExpression
import org.codehaus.groovy.ast.expr.DeclarationExpression
import org.codehaus.groovy.ast.expr.ListExpression
import org.codehaus.groovy.ast.expr.MapExpression
import org.codehaus.groovy.ast.expr.MethodCallExpression
import org.codehaus.groovy.ast.expr.PropertyExpression
import org.codehaus.groovy.ast.expr.RangeExpression
import org.codehaus.groovy.ast.expr.SpreadExpression
import org.codehaus.groovy.ast.expr.SpreadMapExpression
import org.codehaus.groovy.ast.expr.TernaryExpression
import org.codehaus.groovy.ast.expr.VariableExpression
import org.codehaus.groovy.ast.stmt.BlockStatement
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.control.SourceUnit
import java.net.URI

/**
 * Delegate class that handles all actual node visiting for AstVisitor.
 * This separation reduces the AstVisitor function count from 37 to 10.
 *
 * TODO: This class has 29 functions, which naturally occurs in visitor pattern implementations.
 * We've excluded visitor pattern classes from detekt TooManyFunctions rule because each AST
 * node type requires its own visit method. This is a legitimate architectural pattern.
 *
 * The visitor pattern could be further optimized with:
 * - Method dispatch tables instead of individual methods
 * - Reflection-based visiting
 * - Split into specialized visitors (expressions, statements, declarations)
 */
internal class NodeVisitorDelegate(private val tracker: NodeRelationshipTracker) : ClassCodeVisitorSupport() {

    private var _sourceUnit: SourceUnit? = null
    private var currentUri: URI? = null

    public override fun getSourceUnit(): SourceUnit? = _sourceUnit

    fun visitModule(module: ModuleNode, sourceUnit: SourceUnit, uri: URI) {
        this._sourceUnit = sourceUnit
        this.currentUri = uri
        tracker.clear()
        tracker.setModuleNode(uri, module)
        processModule(module)
    }

    private fun processModule(module: ModuleNode) {
        pushNode(module)

        // Visit all imports in the module
        module.imports?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit star imports
        module.starImports?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit static imports
        module.staticImports?.values?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit static star imports
        module.staticStarImports?.values?.forEach { importNode ->
            pushNode(importNode)
            popNode()
        }

        // Visit all classes in the module
        module.classes.forEach { classNode ->
            visitClass(classNode)
        }

        // Also visit any script body code if this is a script
        if (module.statementBlock != null) {
            visitBlockStatement(module.statementBlock)
        }

        popNode()
    }

    /**
     * Push a node onto the stack and track relationships
     */
    private fun pushNode(node: ASTNode) {
        // Only track nodes with valid source positions.
        // This filters out:
        // - Synthetic nodes generated by Groovy compiler (ModuleNode, script methods, etc.)
        // - Nodes with incomplete position information
        //
        // Note: Some VariableExpressions are marked synthetic but have valid coordinates
        // (e.g., implicit access like 'println name') and should be hoverable.
        // By checking position validity instead of synthetic flag, we correctly include these.
        val hasValidPosition = node.lineNumber > 0 && node.columnNumber > 0

        if (hasValidPosition) {
            tracker.pushNode(node, currentUri)
        }
    }

    /**
     * Pop the current node from the stack
     */
    private fun popNode() {
        tracker.popNode()
    }

    private fun <T : ASTNode> visitWithTracking(node: T, visitSuper: (T) -> Unit) {
        pushNode(node)
        try {
            visitSuper(node)
        } finally {
            popNode()
        }
    }

    /**
     * Visit annotations on an annotated node
     */
    override fun visitAnnotations(node: AnnotatedNode) {
        node.annotations?.forEach { annotation ->
            pushNode(annotation)
            try {
                processAnnotationMembers(annotation)
            } finally {
                popNode()
            }
        }
    }

    /**
     * Process annotation members to visit their expressions.
     */
    private fun processAnnotationMembers(annotation: org.codehaus.groovy.ast.AnnotationNode) {
        annotation.members?.forEach { (_, value) ->
            if (value is org.codehaus.groovy.ast.expr.Expression) {
                value.visit(this)
            }
        }
    }

    // Override visitor methods to track nodes

    override fun visitClass(node: ClassNode) {
        visitWithTracking(node) { super.visitClass(it) }
    }

    override fun visitMethod(node: MethodNode) {
        visitWithTracking(node) {
            // Visit parameters
            node.parameters?.forEach { param ->
                pushNode(param)
                popNode()
            }
            super.visitMethod(it)
        }
    }

    override fun visitField(node: FieldNode) {
        visitWithTracking(node) { super.visitField(it) }
    }

    override fun visitProperty(node: PropertyNode) {
        visitWithTracking(node) { super.visitProperty(it) }
    }

    // Expression visitors

    override fun visitMethodCallExpression(call: MethodCallExpression) {
        pushNode(call)
        try {
            // Manually visit arguments to ensure they are tracked, as standard visitor support seems flaky for ArgumentList
            val args = call.arguments
            if (args is org.codehaus.groovy.ast.expr.TupleExpression) {
                args.expressions?.forEach { it.visit(this) }
            } else {
                args?.visit(this)
            }

            // Manually visit the method expression (object and method name) instead of calling super
            // to avoid potential duplicate visitation of arguments if super were to visit them.
            call.objectExpression?.visit(this)
            call.method?.visit(this)
        } finally {
            popNode()
        }
    }

    override fun visitVariableExpression(expression: VariableExpression) {
        visitWithTracking(expression) { super.visitVariableExpression(it) }
    }

    override fun visitDeclarationExpression(expression: DeclarationExpression) {
        pushNode(expression)
        try {
            expression.leftExpression.visit(this)
            expression.rightExpression.visit(this)
        } finally {
            popNode()
        }
    }

    override fun visitBinaryExpression(expression: BinaryExpression) {
        visitWithTracking(expression) { super.visitBinaryExpression(it) }
    }

    override fun visitPropertyExpression(expression: PropertyExpression) {
        visitWithTracking(expression) { super.visitPropertyExpression(it) }
    }

    override fun visitConstructorCallExpression(call: ConstructorCallExpression) {
        visitWithTracking(call) { super.visitConstructorCallExpression(it) }
    }

    override fun visitTupleExpression(expression: org.codehaus.groovy.ast.expr.TupleExpression) {
        visitWithTracking(expression) { super.visitTupleExpression(it) }
    }

    override fun visitClassExpression(expression: ClassExpression) {
        visitWithTracking(expression) { super.visitClassExpression(it) }
    }

    override fun visitClosureExpression(expression: ClosureExpression) {
        visitWithTracking(expression) {
            // Visit closure parameters
            expression.parameters?.forEach { param ->
                pushNode(param)
                popNode()
            }
            super.visitClosureExpression(it)
        }
    }

    override fun visitGStringExpression(expression: org.codehaus.groovy.ast.expr.GStringExpression) {
        visitWithTracking(expression) { super.visitGStringExpression(it) }
    }

    override fun visitConstantExpression(expression: org.codehaus.groovy.ast.expr.ConstantExpression) {
        visitWithTracking(expression) { super.visitConstantExpression(it) }
    }

    override fun visitListExpression(expression: ListExpression) {
        visitWithTracking(expression) { super.visitListExpression(it) }
    }

    override fun visitMapExpression(expression: MapExpression) {
        visitWithTracking(expression) { super.visitMapExpression(it) }
    }

    override fun visitRangeExpression(expression: RangeExpression) {
        visitWithTracking(expression) { super.visitRangeExpression(it) }
    }

    override fun visitTernaryExpression(expression: TernaryExpression) {
        visitWithTracking(expression) { super.visitTernaryExpression(it) }
    }

    override fun visitSpreadExpression(expression: SpreadExpression) {
        visitWithTracking(expression) { super.visitSpreadExpression(it) }
    }

    override fun visitSpreadMapExpression(expression: SpreadMapExpression) {
        visitWithTracking(expression) { super.visitSpreadMapExpression(it) }
    }

    // Statement visitors

    override fun visitBlockStatement(block: BlockStatement) {
        visitWithTracking(block) { super.visitBlockStatement(it) }
    }

    override fun visitExpressionStatement(statement: ExpressionStatement) {
        visitWithTracking(statement) { super.visitExpressionStatement(it) }
    }

    // Additional statement visitors for complete coverage

    override fun visitForLoop(loop: org.codehaus.groovy.ast.stmt.ForStatement) {
        visitWithTracking(loop) { super.visitForLoop(it) }
    }

    override fun visitWhileLoop(loop: org.codehaus.groovy.ast.stmt.WhileStatement) {
        visitWithTracking(loop) { super.visitWhileLoop(it) }
    }

    /**
     * Override visitDoWhileLoop to ensure DoWhileStatement nodes are tracked.
     */
    override fun visitDoWhileLoop(loop: org.codehaus.groovy.ast.stmt.DoWhileStatement) {
        visitWithTracking(loop) { super.visitDoWhileLoop(it) }
    }

    override fun visitIfElse(ifElse: org.codehaus.groovy.ast.stmt.IfStatement) {
        visitWithTracking(ifElse) { super.visitIfElse(it) }
    }

    /**
     * Override visitTryCatchFinally to ensure TryCatchStatement and CatchStatement nodes are tracked.
     *
     * Note: CatchStatement doesn't have its own visitor method in ClassCodeVisitorSupport,
     * so we manually track each catch statement along with its parameter and code block.
     */
    override fun visitTryCatchFinally(statement: org.codehaus.groovy.ast.stmt.TryCatchStatement) {
        pushNode(statement)
        try {
            // Manually visit catch statements to ensure they are tracked
            statement.catchStatements?.forEach { catchStmt ->
                pushNode(catchStmt)
                try {
                    // Visit the catch parameter
                    val param = catchStmt.variable
                    if (param != null) {
                        pushNode(param)
                        popNode()
                    }
                    // Visit the catch block
                    catchStmt.code?.visit(this)
                } finally {
                    popNode()
                }
            }

            // Visit try block
            statement.tryStatement?.visit(this)

            // Visit finally block
            statement.finallyStatement?.visit(this)
        } finally {
            popNode()
        }
    }

    override fun visitReturnStatement(statement: org.codehaus.groovy.ast.stmt.ReturnStatement) {
        visitWithTracking(statement) { super.visitReturnStatement(it) }
    }

    override fun visitThrowStatement(statement: org.codehaus.groovy.ast.stmt.ThrowStatement) {
        visitWithTracking(statement) { super.visitThrowStatement(it) }
    }

    /**
     * Override visitSwitch to ensure SwitchStatement and all CaseStatement nodes are tracked.
     *
     * We manually visit each case statement to ensure comprehensive tracking of all switch cases,
     * including the default case. This ensures that case statements are hoverable and discoverable.
     */
    override fun visitSwitch(statement: org.codehaus.groovy.ast.stmt.SwitchStatement) {
        pushNode(statement)
        try {
            // Visit the expression being switched on
            statement.expression?.visit(this)

            // Manually visit case statements to ensure they are all tracked
            statement.caseStatements?.forEach { caseStmt ->
                visitCaseStatement(caseStmt)
            }

            // Visit the default statement if it exists
            statement.defaultStatement?.visit(this)
        } finally {
            popNode()
        }
    }

    /**
     * Override visitCaseStatement to ensure CaseStatement nodes are tracked.
     */
    override fun visitCaseStatement(statement: org.codehaus.groovy.ast.stmt.CaseStatement) {
        visitWithTracking(statement) { super.visitCaseStatement(it) }
    }

    /**
     * Override visitBreakStatement to ensure BreakStatement nodes are tracked.
     */
    override fun visitBreakStatement(statement: org.codehaus.groovy.ast.stmt.BreakStatement) {
        visitWithTracking(statement) { super.visitBreakStatement(it) }
    }

    /**
     * Override visitContinueStatement to ensure ContinueStatement nodes are tracked.
     */
    override fun visitContinueStatement(statement: org.codehaus.groovy.ast.stmt.ContinueStatement) {
        visitWithTracking(statement) { super.visitContinueStatement(it) }
    }
}
