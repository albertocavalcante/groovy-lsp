package com.github.albertocavalcante.groovylsp.providers.hover

import com.github.albertocavalcante.groovylsp.compilation.GroovyCompilationService
import com.github.albertocavalcante.groovylsp.fixtures.HoverTestWithTitleSpec
import kotlinx.coroutines.test.runTest
import org.eclipse.lsp4j.MarkupKind
import org.eclipse.lsp4j.Position
import org.junit.jupiter.api.Test
import java.net.URI
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Systematic tests for all 40+ expression node types.
 * This test ensures that every expression AST node type can provide meaningful hover information.
 * Organized by priority phases for comprehensive coverage.
 */
class HoverExpressionNodesTest {

    private val compilationService = GroovyCompilationService()
    private val hoverProvider = HoverProvider(compilationService)

    /**
     * Helper function to test hover at a specific position and validate the response.
     */
    private suspend fun testHoverAt(spec: HoverTestWithTitleSpec) = testHoverAt(
        spec.code,
        spec.line,
        spec.character,
        spec.description,
        spec.expectedTitle,
        spec.expectedContent,
        spec.shouldHaveHover,
    )

    data class HoverTestParams(
        val code: String,
        val line: Int,
        val character: Int,
        val description: String,
        val expectedTitle: String? = null,
        val expectedContent: String? = null,
        val shouldHaveHover: Boolean = true,
    )

    private suspend fun testHoverAt(params: HoverTestParams) = testHoverAtImpl(params)

    private suspend fun testHoverAtImpl(params: HoverTestParams) {
        val uri = URI.create("file:///test.groovy")
        compilationService.compile(uri, params.code)
        val hover = hoverProvider.provideHover(uri.toString(), Position(params.line, params.character))

        if (params.shouldHaveHover) {
            assertNotNull(hover, "Expected hover at ${params.line}:${params.character} for ${params.description}")
            assertTrue(hover.contents.isRight, "Should have markup content for ${params.description}")

            val content = hover.contents.right
            assertEquals(MarkupKind.MARKDOWN, content.kind, "Should be markdown content for ${params.description}")

            // Should NOT show "No information available"
            assertFalse(
                content.value.contains("No information available"),
                "Should NOT show 'No information available' for ${params.description}, got: ${content.value}",
            )

            if (params.expectedTitle != null) {
                assertTrue(
                    content.value.contains(params.expectedTitle),
                    "Should contain title '${params.expectedTitle}' for ${params.description}, got: ${content.value}",
                )
            }

            if (params.expectedContent != null) {
                assertTrue(
                    content.value.contains(params.expectedContent),
                    "Should contain '${params.expectedContent}' for ${params.description}, got: ${content.value}",
                )
            }
        } else {
            assertNotNull(hover, "Should not have hover for ${params.description}")
        }
    }

    // ======== PHASE 1: HIGH PRIORITY EXPRESSION NODES ========

    @Test
    fun `should provide hover for ArgumentListExpression`() = runTest {
        val code = """
            class TestClass {
                def method(String name, int age) {
                    println(name, age)
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 12, // On "(name, age)" in println call
            description = "argument list expression",
            expectedTitle = "Argument List",
            expectedContent = "Arguments",
        )
    }

    @Test
    fun `should provide hover for ArrayExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    String[] names = new String[]{"Alice", "Bob"}
                    int[] numbers = new int[]{1, 2, 3}
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 30, // On array creation
            description = "array expression",
            expectedTitle = "Array Expression",
            expectedContent = "Element Type",
        )
    }

    @Test
    fun `should provide hover for ListExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def list = ["Alice", "Bob", "Charlie"]
                    def numbers = [1, 2, 3, 4, 5]
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 19, // On list literal
            description = "list expression",
            expectedTitle = "List Expression",
            expectedContent = "Size",
        )
    }

    @Test
    fun `should provide hover for MapExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def person = [name: "Alice", age: 30]
                    def config = [debug: true, timeout: 5000]
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 21, // On map literal
            description = "map expression",
            expectedTitle = "Map Expression",
            expectedContent = "Entries",
        )
    }

    @Test
    fun `should provide hover for MapEntryExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def map = [key: "value", number: 42]
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 19, // On "key: 'value'" entry
            description = "map entry expression",
            expectedTitle = "Map Entry",
            expectedContent = "Key",
        )
    }

    @Test
    fun `should provide hover for RangeExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def range1 = 1..10
                    def range2 = 0..<5
                    for (i in 1..100) { println(i) }
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 21, // On "1..10" range
            description = "inclusive range expression",
            expectedTitle = "Range Expression",
            expectedContent = "Inclusive",
        )

        testHoverAt(
            code = code,
            line = 3,
            character = 21, // On "0..<5" range
            description = "exclusive range expression",
            expectedTitle = "Range Expression",
            expectedContent = "Inclusive",
        )
    }

    @Test
    fun `should provide hover for TernaryExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def result = condition ? "yes" : "no"
                    def value = x > 0 ? x : -x
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 25, // On ternary operator
            description = "ternary expression",
            expectedTitle = "Ternary Expression",
            expectedContent = "Condition",
        )
    }

    @Test
    fun `should provide hover for CastExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def obj = (String) value
                    def num = (int) 3.14
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 18, // On cast expression
            description = "cast expression",
            expectedTitle = "Type Cast",
            expectedContent = "Target Type",
        )
    }

    @Test
    fun `should provide hover for ElvisOperatorExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def name = input ?: "default"
                    def value = config.timeout ?: 30
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 21, // On elvis operator
            description = "elvis operator expression",
            expectedTitle = "Elvis Operator",
            expectedContent = "Primary",
        )
    }

    @Test
    fun `should provide hover for MethodPointerExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def method = object.&methodName
                    def func = String.&valueOf
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 25, // On method pointer
            description = "method pointer expression",
            expectedTitle = "Method Pointer",
            expectedContent = "Method reference",
        )
    }

    // ======== PHASE 2: MEDIUM PRIORITY EXPRESSION NODES ========

    @Test
    fun `should provide hover for PostfixExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    int i = 0
                    i++
                    j--
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 3,
            character = 8, // On "i++"
            description = "postfix increment expression",
            expectedTitle = "Postfix Expression",
            expectedContent = "Post-increment",
        )
    }

    @Test
    fun `should provide hover for PrefixExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    int i = 0
                    ++i
                    --j
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 3,
            character = 8, // On "++i"
            description = "prefix increment expression",
            expectedTitle = "Prefix Expression",
            expectedContent = "Pre-increment",
        )
    }

    @Test
    fun `should provide hover for UnaryMinusExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def negative = -value
                    def result = -42
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 23, // On "-value"
            description = "unary minus expression",
            expectedTitle = "Unary Minus",
            expectedContent = "Negation",
        )
    }

    @Test
    fun `should provide hover for UnaryPlusExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def positive = +value
                    def result = +42
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 23, // On "+value"
            description = "unary plus expression",
            expectedTitle = "Unary Plus",
            expectedContent = "Positive",
        )
    }

    @Test
    fun `should provide hover for NotExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def result = !condition
                    if (!flag) { return }
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 21, // On "!condition"
            description = "logical NOT expression",
            expectedTitle = "Logical NOT",
            expectedContent = "Logical negation",
        )
    }

    @Test
    fun `should provide hover for BitwiseNegationExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def complement = ~bits
                    def result = ~0xFF
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 25, // On "~bits"
            description = "bitwise negation expression",
            expectedTitle = "Bitwise NOT",
            expectedContent = "Bitwise complement",
        )
    }

    @Test
    fun `should provide hover for BooleanExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    if (condition && flag) { return true }
                    while (running || paused) { wait() }
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 8, // On boolean condition
            description = "boolean expression",
            expectedTitle = "Boolean Expression",
            expectedContent = "Boolean",
        )
    }

    // ======== PHASE 3: ADVANCED/LESS COMMON EXPRESSION NODES ========

    @Test
    fun `should provide hover for TupleExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def (a, b, c) = [1, 2, 3]
                    return (x, y, z)
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 12, // On tuple in multiple assignment
            description = "tuple expression",
            expectedTitle = "Tuple Expression",
            expectedContent = "Multiple assignment",
        )
    }

    @Test
    fun `should provide hover for SpreadExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def list = [1, 2, 3]
                    def expanded = [0, *list, 4]
                    method(*args)
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 3,
            character = 23, // On "*list" spread
            description = "spread expression",
            expectedTitle = "Spread Expression",
            expectedContent = "Spread operator",
        )
    }

    @Test
    fun `should provide hover for SpreadMapExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def base = [a: 1, b: 2]
                    def extended = [*:base, c: 3]
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 3,
            character = 24, // On "*:base" spread map
            description = "spread map expression",
            expectedTitle = "Spread Map Expression",
            expectedContent = "Spread operator for maps",
        )
    }

    @Test
    fun `should provide hover for NamedArgumentListExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    method(name: "Alice", age: 30, active: true)
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 15, // On named arguments
            description = "named argument list expression",
            expectedTitle = "Named Arguments",
            expectedContent = "Named parameter list",
        )
    }

    @Test
    fun `should provide hover for LambdaExpression`() = runTest {
        val code = """
            import java.util.function.Function

            class TestClass {
                def test() {
                    Function<String, Integer> func = s -> s.length()
                    def lambda = (x, y) -> x + y
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 4,
            character = 45, // On lambda expression
            description = "lambda expression",
            expectedTitle = "Lambda Expression",
            expectedContent = "Lambda/Closure",
        )
    }

    @Test
    fun `should provide hover for ClosureListExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def closures = [
                        { x -> x * 2 },
                        { y -> y + 1 },
                        { z -> z / 2 }
                    ]
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 2,
            character = 23, // On closure list
            description = "closure list expression",
            expectedTitle = "Closure List",
            expectedContent = "List of closure expressions",
        )
    }

    @Test
    fun `should provide hover for EmptyExpression`() = runTest {
        val code = """
            class TestClass {
                def test() {
                    def array = new Object[10]
                    // EmptyExpression appears in default parameter values
                    def method(param = ) { }
                }
            }
        """.trimIndent()

        // EmptyExpression is harder to test directly as it's often internal
        // This test validates our converter exists
        testHoverAt(
            code = code,
            line = 2,
            character = 20, // Test array creation which may contain empty expressions
            description = "empty expression context",
            expectedContent = "Object",
        )
    }

    @Test
    fun `should provide hover for MethodReferenceExpression`() = runTest {
        val code = """
            import java.util.function.Function

            class TestClass {
                def test() {
                    Function<String, Integer> func = String::length
                    def method = TestClass::staticMethod
                }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 4,
            character = 45, // On method reference
            description = "method reference expression",
            expectedTitle = "Method Reference",
            expectedContent = "Method reference for functional programming",
        )
    }

    @Test
    fun `should provide hover for AnnotationConstantExpression`() = runTest {
        val code = """
            @SuppressWarnings("unchecked")
            class TestClass {
                @Deprecated("Use newMethod instead")
                def oldMethod() { }
            }
        """.trimIndent()

        testHoverAt(
            code = code,
            line = 0,
            character = 18, // On annotation constant value
            description = "annotation constant expression",
            expectedTitle = "Annotation Constant",
            expectedContent = "Annotation constant",
        )
    }

    // ======== COMPREHENSIVE INTEGRATION TESTS ========

    @Test
    fun `should provide hover for complex nested expressions`() = runTest {
        val code = """
            class TestClass {
                def complexMethod() {
                    def result = (list?.collect { it.name } ?: [])
                        .findAll { it.startsWith("A") }
                        .sort()
                        .join(", ")

                    def ternary = condition ?
                        map.get("key") ?: "default" :
                        array[index] ?: fallback

                    return [*:baseMap, result: result, success: true]
                }
            }
        """.trimIndent()

        // Test safe navigation
        testHoverAt(
            code = code,
            line = 2,
            character = 25, // On "collect" method call
            description = "safe navigation method call",
            expectedContent = "Method Call",
        )

        // Test elvis operator
        testHoverAt(
            code = code,
            line = 2,
            character = 40, // On elvis operator
            description = "elvis operator in complex expression",
            expectedTitle = "Elvis Operator",
        )

        // Test spread map
        testHoverAt(
            code = code,
            line = 9,
            character = 19, // On spread map
            description = "spread map in complex expression",
            expectedTitle = "Spread Map Expression",
        )
    }
}
